/*
 * Copyright (C) 2021, HENSOLDT Cyber GmbH
 */

/**
 * @file
 *
 * Generic TRENTOS Network Stack CAmkES template code.
 *
 * This file provides macros that can be used for the definition of a network stack
 * component. The network stack component implements the socket interface
 * (if_OS_Socket) and connects to a NIC driver component via the NIC component
 * interface (if_OS_Nic).
 */

#pragma once

import <std_connector.camkes>;
import <global-connectors.camkes>;

#include "lib_macros/ForEach.h"

#include <if_OS_Nic.camkes>

/** @cond SKIP_IMPORTS */
import <if_OS_Socket.camkes>;
import <if_OS_Timer.camkes>;
/** @endcond */

//------------------------------------------------------------------------------

struct NetworkStack_ClientConfig {
    int socket_quota;
}

struct NetworkStack_Config {
    NetworkStack_ClientConfig clients[];
}

// Private macros --------------------------------------------------------------

#define _NWSTACK_EMPTY

#define _NWSTACK_MACRO_LOOP_1(_m_)      _m_(1)
#define _NWSTACK_MACRO_LOOP_2(_m_)      _m_(2)  _NWSTACK_MACRO_LOOP_1(_m_)
#define _NWSTACK_MACRO_LOOP_3(_m_)      _m_(3)  _NWSTACK_MACRO_LOOP_2(_m_)
#define _NWSTACK_MACRO_LOOP_4(_m_)      _m_(4)  _NWSTACK_MACRO_LOOP_3(_m_)
#define _NWSTACK_MACRO_LOOP_5(_m_)      _m_(5)  _NWSTACK_MACRO_LOOP_4(_m_)
#define _NWSTACK_MACRO_LOOP_6(_m_)      _m_(6)  _NWSTACK_MACRO_LOOP_5(_m_)
#define _NWSTACK_MACRO_LOOP_7(_m_)      _m_(7)  _NWSTACK_MACRO_LOOP_6(_m_)
#define _NWSTACK_MACRO_LOOP_8(_m_)      _m_(8)  _NWSTACK_MACRO_LOOP_7(_m_)
#define _NWSTACK_MACRO_LOOP_9(_m_)      _m_(9)  _NWSTACK_MACRO_LOOP_8(_m_)
#define _NWSTACK_MACRO_LOOP_10(_m_)     _m_(10) _NWSTACK_MACRO_LOOP_9(_m_)
#define _NWSTACK_MACRO_LOOP_11(_m_)     _m_(11) _NWSTACK_MACRO_LOOP_10(_m_)
#define _NWSTACK_MACRO_LOOP_12(_m_)     _m_(12) _NWSTACK_MACRO_LOOP_11(_m_)
#define _NWSTACK_MACRO_LOOP_13(_m_)     _m_(13) _NWSTACK_MACRO_LOOP_12(_m_)
#define _NWSTACK_MACRO_LOOP_14(_m_)     _m_(14) _NWSTACK_MACRO_LOOP_13(_m_)
#define _NWSTACK_MACRO_LOOP_15(_m_)     _m_(15) _NWSTACK_MACRO_LOOP_14(_m_)
#define _NWSTACK_MACRO_LOOP_16(_m_)     _m_(16) _NWSTACK_MACRO_LOOP_15(_m_)

/**
 * Internal macro that will expand into multiple invocations of the macro passed
 * as argument passing to it the number of the invocation as argument.
 *
 * @param[in] cnt   Number of invocations.
 * @param[in] macro Macro that has to be invoked.
 */
#define _NWSTACK_MACRO_LOOP(cnt, macro) \
    _NWSTACK_MACRO_LOOP_##cnt(macro)

/**
 * Internal macro that connects the events internally used by the network stack
 * associated to socket activity.
 *
 * @param[in] n Number of the socket.
 */
#define _NWSTACK_CONNECT_SOCKET(n) \
    connection seL4Notification conn_event_write_##n( \
        from e_write_##n, \
        to   c_write_##n); \
    \
    connection seL4Notification conn_event_read_##n( \
        from e_read_##n, \
        to   c_read_##n); \
    \
    connection seL4Notification conn_event_connect_##n( \
        from e_conn_##n, \
        to   c_conn_##n);

/**
 * Internal macro that used to configure the socket quota for each connected
 * client.
 */
#define NetworkStack_PicoTcp_INSTANCE_CONFIGURATOR( \
    _unused0, \
    _unused1_, \
    _socket_quota_, \
    _unused2_) \
    \
    { \
        "socket_quota": _socket_quota_ \
    },

// Public macros ---------------------------------------------------------------

/**
 * Declare a socket number 'n' as member of the network stack.
 *
 * It declares the fields needed for a socket connection.
 *
 * @param[in] n Number of the socket.
 */
#define NetworkStack_PicoTcp_Socket_DECLARE(n) \
    emits     NetworkStack_PicoTcp_WrEv    e_write_##n; \
    consumes  NetworkStack_PicoTcp_WrEv    c_write_##n; \
    \
    emits     NetworkStack_PicoTcp_RdEv    e_read_##n; \
    consumes  NetworkStack_PicoTcp_RdEv    c_read_##n; \
    \
    emits     NetworkStack_PicoTcp_ConnEv  e_conn_##n; \
    consumes  NetworkStack_PicoTcp_ConnEv  c_conn_##n;

//! Macro for the component definition if no other interfaces are used.
#define NetworkStack_PicoTcp_NO_ADDITIONAL_INTERFACES _NWSTACK_EMPTY

/**
 * Defines a network stack component.
 *
 * It can offer one or more socket interfaces and can connect to a NIC driver
 * component via the NIC component interface.
 *
 * @param[in] name             Name of the network stack component. This is
 *                             meant not to be an instance name but rather a
 *                             'type' name.
 * @param[in] nic_port_size    Size of the dataport to connect to the NIC driver
 *                             component.
 * @param[in] num_sockets      Number of socket connections that the network
 *                             stack can offer.
 * @param[in] other_interfaces Definitions of fields of additional interfaces to
 *                             which this component could connect to (e.g.: a
 *                             logger component to log its error messages).
 */
#define NetworkStack_PicoTcp_COMPONENT_DEFINE( \
    name, \
    nic_port_size, \
    num_sockets, \
    other_interfaces) \
    \
    component name \
    { \
        control; \
        \
        consumes  EventDataAvailable    event_tick_or_data; \
        emits     EventDataAvailable    event_internal; \
        has       mutex                 allocatorMutex; \
        has       mutex                 nwstackMutex; \
        has       mutex                 socketControlBlockMutex; \
        has       mutex                 stackThreadSafeMutex; \
        attribute NetworkStack_Config   networkStack_config; \
        \
        /*------------------------------------------------------------------*/ \
        /* interface TimeServer */ \
        uses      if_OS_Timer           timeServer_rpc; \
        consumes  TimerReady            timeServer_notify; \
        \
        /*------------------------------------------------------------------*/ \
        /* if_OS_Nic without a dedicated event, because our interface */ \
        /* 'event_tick_or_data' is a shared sink for multiple event sources */ \
        IF_OS_NIC_USE_WITHOUT_EVENT(nic, nic_port_size) \
        \
        /*------------------------------------------------------------------*/ \
        /* interface to application */ \
        provides  if_OS_Socket          networkStack_rpc; \
        _NWSTACK_MACRO_LOOP(num_sockets, NetworkStack_PicoTcp_Socket_DECLARE) \
        /*------------------------------------------------------------------*/ \
        /* other interfaces */ \
        other_interfaces \
        \
        composition \
        { \
            connection seL4NotificationNative conn_event_internal( \
                from event_internal, \
                to   event_tick_or_data); \
            \
            _NWSTACK_MACRO_LOOP(num_sockets, _NWSTACK_CONNECT_SOCKET) \
        } \
    }

/**
 * Connects a network stack instance to a ticker event and a NIC component.
 *
 * So far, all NIC component interface related fields of the network stack use
 * the prefix 'nic', and the same prefix is also used by all network drivers for
 * their NIC component interface related fields. As long a no NIC driver breaks
 * this scheme (e.g. because it has multiple NIC component interfaces), there is
 * no need to have an additional macro parameter here that passes the driver's
 * prefix.
 *
 * @param[in] inst             Name of the network stack component instance.
 * @param[in] ticker_event_src Source ticker event to connect to the network
 *                             stack.
 * @param[in] nic_inst         Name of the NIC component instance to which the
 *                             network stack component has to connect to.
 */
#define NetworkStack_PicoTcp_INSTANCE_CONNECT( \
    inst, \
    ticker_event_src, \
    nic_inst) \
    \
    connection seL4NotificationNative conn_event_##inst##_ticker( \
        from ticker_event_src, \
        to   inst.event_tick_or_data); \
    \
    IF_OS_NIC_CONNECT(\
        nic_inst, \
        nic, \
        inst, \
        nic, \
        event_tick_or_data)

/**
 * Connects a client component to a network stack through sockets.
 *
 * @param[in] inst        Name of the network stack component instance.
 * @param[in] client      Name of client component instance.
 * @param[in] client_rpc  Name of the client RPC to connect to the socket RPC.
 * @param[in] ...         List of client dataport names to connect to the
 *                        sockets. Each socket, by design, needs a dataport.
 *                        WARNING: Regardless of the amount of sockets that a
 *                        user component may need from a network stack it is
 *                        mandatory that each dataport of the network stack gets
 *                        connected to a corresponding one on the user component
 *                        side.
 */
#define NetworkStack_PicoTcp_CLIENT_CONNECTOR( \
    _inst_, \
    _unused_, \
    _client_, \
    _client_rpc_, \
    ...) \
    connection seL4RPCDataport conn_rpc_##_client_##_##_inst_( \
        from _client_._client_rpc_, \
        to   _inst_.networkStack_rpc);

#define NetworkStack_PicoTcp_INSTANCE_CONNECT_CLIENTS( \
    _inst_, \
    ...) \
    \
    FOR_EACH_2P(NetworkStack_PicoTcp_CLIENT_CONNECTOR,_inst_,UNUSED,__VA_ARGS__)

// Assign a single badge; this is used internally
#define NetworkStack_PicoTcp_BADGE_ASSIGNER( \
    _unused0_, \
    _unused1_, \
    _rpc_, \
    _num_) \
    \
    _rpc_ ## _attributes = (100 + _num_);

/**
 * Assign all clients a badge, in the order in which they are connected to the
 * StorageServer instance via NetworkStack_PicoTcp_INSTANCE_CONNECT_CLIENTS():
 *
 *      NetworkStack_PicoTcp_CLIENT_ASSIGN_BADGE(
 *          <client_rpc>, <ID>
 *      )
 *
 * NOTE: IDs need to start at 101!
 *
 */
#define NetworkStack_PicoTcp_CLIENT_ASSIGN_BADGE( \
    _rpc_, \
    _val_) \
    \
    _rpc_ ## _attributes = _val_;

/**
 * Assign badges to a list of clients; badge IDs will start at 101 and then be
 * incremented. Make sure to pass clients in same order as they are passed
 * in the NetworkStack_PicoTcp_INSTANCE_CONNECT_CLIENTS() macro:
 *
 *      NetworkStack_PicoTcp_CLIENT_ASSIGN_BADGES(
 *          <client0_rpc>,
 *          <client1_rpc>,
 *           ...
 *      )
 *
 * NOTE: Can take up to 8 clients.
 *
 */
#define NetworkStack_PicoTcp_CLIENT_ASSIGN_BADGES( \
    ...) \
    \
    FOR_EACH_1P(NetworkStack_PicoTcp_BADGE_ASSIGNER,UNUSED,UNUSED,__VA_ARGS__)

/**
 * Configure all clients connected to a NetworkStack_PicoTc instance:
 *
 *      NetworkStack_PicoTcp_INSTANCE_CONFIGURE_CLIENTS(
 *          <instance>,
 *          <socket_quota0>,
 *          <socket_quota1>,
 *          ...
 *      )
 * Make sure to pass clients in same order as they are passed in the
 * NetworkStack_PicoTcp_INSTANCE_CONNECT_CLIENTS() macro.
 */
#define NetworkStack_PicoTcp_INSTANCE_CONFIGURE_CLIENTS( \
    _inst_, \
    ...) \
    \
    _inst_.networkStack_config = { \
        "clients": [ \
            FOR_EACH_1P(NetworkStack_PicoTcp_INSTANCE_CONFIGURATOR, \
                        UNUSED,UNUSED,__VA_ARGS__) \
        ] \
    };
